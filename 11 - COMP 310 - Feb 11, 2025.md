
# Back to the dragon problem : 

As seen previously in the [[Pet dragon problem]], 

What does this mean?
- **Alice and Bob** : threads in the same process
- **Pond** : shared memory region that needs to be accessed in a mutually exclusive way
- **Dragons** : functions of the thread's code that needs to access the shared memory

- **Trees** : a metaphor that means that threads cannot observe the state of the shared memory region with confidence 
	- Because threads can be interrupted by the OS at any time AND for an indefinite amount of time

- **Flags** : bits that dragons/threads use to coordinate their access to the shared memory region
	- in a program with $n$ threads, we initialize an array of size $n$
	- each thread can write a SINGLE entry
	- each thread can read all the other entries


# Peterson's algorithm

## Code starting point : 

```c
Alice() {  
	raise flag  
	point sign at Bob  
	while (Bob’s flag & sign pointed at Bob) { }  
	release pet dragon  
	lower flag when pet returns  
}
```

```c
Bob() {  
	raise flag  
	point sign at Alice  
	while (Alice’s flag & sign pointed at Alice) { }  
	release pet dragon  
	lower flag when pet returns  
}
```

## Proving correctness : 

### For mutual exclusion
We can prove that this is **mutually exclusive** BY CONTRADICTION

Assume both dragons are in the pond at the same time
- Alice's dragon being there means that Bob's flag is down OR that the sign is pointed at Alice
- Therefore, the sign is pointed at Alice
- But Bob => !(Alice’s flag & sign pointed at Alice) => ...  
- Likewise, either Alice’s pet isn’t in the pond, or sign -> Bob.  
- In either case, **contradiction**!

### For no deadlocks 
The only possible deadlock is during the while loop
- (Bob’s flag & sign pointed at Alice) and  (Alice’s flag & sign pointed at Bob)
- But these CANNOT be true at the same time, so if Alice and Bob are in the while loop, one can advance

### For no starvation (weak liveness)
 - Bob can't just keep using the pond without giving Alice a turn (or vice-versa)

- After giving up the pond, if Bob wants to use it again, he must : 
	- raise his flag 
	- point the sign at Alice

- This will guarantee that Alice gets a turn if she wants one

---

# Memory hierarchy

![[Screenshot 2025-02-11 at 10.46.56 AM.webp]]


> [!Warning] Assumption : 
> For THIS WEEK only, all of a program must be in the **main memory**

# Goals of OS memory management
1. <mark style="background: #ADCCFFA6;">Main memory allocation</mark>
	- Where to locate the kernel?
	- How many processes do we allow?
	- what memory to allocate processes?

2. <mark style="background: #ADCCFFA6;">Protection</mark>
	- cannot corrupt OS / other processes
	- **Privacy** : cannot read data of other processes

3. <mark style="background: #ADCCFFA6;">Transparency</mark>
	- processes are NOT aware that memory is shared
	- works regardless of the number and/or location of the procedures

## Protection
We must not be able to read/write the memory of other processes or from the kernel

### Protected memory access
![[Screenshot 2025-02-11 at 10.54.47 AM.webp]]
- This works! Process 150 belongs to the P1 memory 

![[Screenshot 2025-02-11 at 10.56.02 AM.webp]]
- This doesn't work, 500 does NOT belong to the P1 memory


## Transparency
The programmer shouldn't have to worry about WHERE the program is in memory NOR what / where other processes are in memory

![[Screenshot 2025-02-11 at 10.58.09 AM.webp]]



## Main memory allocation
- Where do we locate the kernel?
- How many processes do we allow?
- What memory do we allocate to different processes?

### For the kernel
- normally, in low memory
	- why? because (x86) interrupt vectors are in low memory

### For different processes
![[Screenshot 2025-02-11 at 11.01.49 AM.webp]]

#### Uniprogramming
- this used to be the norm.
- only one process runs at a time, and the process can see the physical memory
![[Screenshot 2025-02-11 at 11.07.54 AM.webp]]

This was BAD ! 
- time is lost
- the process can destroy the OS, there's no protection


# Virtualizing memory
How can the OS give off the illusion of having a private, and large memory space for multiple running processes on top of a single, physical memory?

- Virtual address space : what the program/programmer thinks is its actual memory
	- the address generated by the CPU
- Physical address space : where the program actually is in memory
	- the address that the memory sees

![[Screenshot 2025-02-11 at 11.11.40 AM.webp|615]]


## Memory management unit (MMU)
- provides mapping from virtual to physical
- provides protection at the same time
- hardware

![[Screenshot 2025-02-11 at 11.13.14 AM.webp]]
- This is inside P1's mapped range 

![[Screenshot 2025-02-11 at 11.14.08 AM.webp]]
- This is OUTSIDE of P1's mapped range


## Code in virtual memory

![[Screenshot 2025-02-11 at 11.16.48 AM.webp]]
slide 39 - lecture 6

- the MMU translates the 16KB of data inside the virtual address space INTO the 16KB of data inside the physical memory
	- 32KB --> 48KB


## Size of address spaces

- the maximum **virtual address space** size is limited by the address size of the **CPU**
	- typically either 32 or 64 bit addresses

- the maximum **physical address space** size is limited by the size of memory (**RAM**)
	- now, 10s-100s of GB
	- BUT the <mark style="background: #D2B3FFA6;">MMU exceeds the RAM sizes</mark>
		- high-end modern RAM : 39 bits
		- standard modern MMU : 52 bits




DNode rectangle = new DNode;
rectangle.element = rectangle
rectangle.next = null;
rectangle.prev = star;

star.next = rectangle;

